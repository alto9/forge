---
alwaysApply: true
---

# Forge - Context Engineering for Agentic Development

You are helping me build and maintain Forge, a comprehensive toolkit for structured context engineering in AI-assisted development. This is a meta-project where we are using Forge itself to build Forge, demonstrating the power of session-driven context engineering.

## What Forge Is

Forge is a session-driven workflow system for structured context engineering in AI-assisted development. It helps engineers design software systematically by tracking changes during design sessions, then distills those sessions into minimal, actionable implementation stories (< 30 minutes each) with complete context.

## Current Project State

This repository contains Forge itself - both the VSCode extension and MCP server. We are actively using Forge to build Forge, creating a comprehensive set of features, specs, actors, and contexts that define the complete user experience and technical implementation.

## The Big Picture

A developer would install Forge at the start of a project. Using Forge, a set of files in a folder named 'ai' in the root of the project would get managed. The folders are:

- ai/sessions - Design session tracking
- ai/features - Feature definitions with Gherkin scenarios
- ai/specs - Technical specifications with Mermaid diagrams
- ai/actors - Actor/persona definitions
- ai/contexts - Context references and guidance
- ai/tickets - Implementation Stories and Tasks
- ai/docs - Supporting documentation

All folders except 'docs' are nestable, and nesting is preferred to maximize contextual structure.

## File Structure

### Sessions (ai/sessions/)
- Session files (*.session.md) track design sessions
- Contains: session_id, start_time, end_time, status, problem_statement, changed_files[]
- Tracks all file changes made during the session

### Features (ai/features/)
- Feature files (*.feature.md) define user-facing functionality
- Uses Gherkin format in code blocks (```gherkin)
- Every features folder should have an index.md with Background and Rules
- Contains: feature_id, spec_id[]

### Specs (ai/specs/)
- Spec files (*.spec.md) define technical implementation
- Includes Mermaid diagrams for architecture
- Contains: spec_id, feature_id[], context_id[]

### Actors (ai/actors/)
- Actor files (*.actor.md) define system actors and personas
- Describes who interacts with the system and their roles
- Contains: actor_id, type (user/system/external), responsibilities, characteristics
- Used to inform feature design and user experience

### Contexts (ai/contexts/)
- Context files (*.context.md) provide just-in-time guidance
- Uses Gherkin scenarios in code blocks (```gherkin)
- Tells agents when/how to use specific documentation or tools
- Contains: context_id, category

### Tickets (ai/tickets/)
- Stories (*.story.md) - code implementation work (< 30 minutes each)
- Tasks (*.task.md) - external/manual work
- Organized by session in ai/tickets/<session-id>/
- Contains: story_id/task_id, session_id, feature_id[], spec_id[], status

## The Workflow

### Phase 1: Start a Design Session
1. User runs "Foundry: Start Design Session" command
2. System prompts for problem statement
3. Creates session file in ai/sessions/ with status: active
4. Session begins tracking changed files

### Phase 2: Design Changes
During an active session, user edits:
- Features (define/modify behavior with Gherkin)
- Specs (technical implementation with Mermaid)
- Actors (define system personas and roles)
- Contexts (guidance for specific technologies)

All changes are tracked in the session's changed_files array.

### Phase 3: Distill Session
1. User runs "Foundry: Distill Session into Stories and Tasks"
2. System generates prompt that:
   - Calls get_Foundry_about MCP tool
   - Analyzes all changed files
   - Follows context linkages
   - Creates Stories (code) and Tasks (non-code)
   - Places them in ai/tickets/<session-id>/

### Phase 4: Build Implementation
1. User selects a Story file
2. Runs "Foundry: Build Story Implementation"
3. System generates prompt with full context from linked features, specs, and contexts

## Key Principles

### Gherkin Format
ALL Gherkin must use code blocks for consistency:

```gherkin
Feature: User Login

Scenario: Successful login
  Given a registered user
  When they enter valid credentials
  Then they should be logged into the system
  And receive a session token
```

### Minimal Stories
- Each story should take < 30 minutes to implement
- Break complex changes into multiple small stories
- One focused change per story

### Nestable Structure
- All folders are nestable to group related concepts
- Features folders have index.md for shared Background and Rules
- index.md files never show in tree views

### Complete Context
- Stories link to features, specs, and contexts
- Context files provide technical guidance
- Distillation follows all linkages to gather complete information

## VSCode Commands

The extension provides these commands:

### Foundry: Start Design Session
- Accessible from command palette and right-click on 'sessions' folder
- Prompts for problem statement
- Generates prompt to create session file
- Outputs to Foundry output panel for copy/paste

### Foundry: Distill Session into Stories and Tasks
- Accessible from command palette and right-click on *.session.md files
- Generates comprehensive distillation prompt
- Analyzes all changed files
- Calls get_Foundry_about to understand workflow
- Creates Stories and Tasks in ai/tickets/<session-id>/

### Foundry: Build Story Implementation
- Accessible from command palette and right-click on *.story.md files
- Generates build prompt with full context
- Includes linked features, specs, and contexts
- Ready for AI agent to implement

### Forge: Open Forge Studio
- Opens comprehensive React-based webview interface
- Dashboard with project overview and session status
- Full file management for all Forge file types (Features, Specs, Actors, Contexts, Sessions)
- Nested folder creation and navigation
- File creation with proper templates and frontmatter
- Session-aware editing (requires active session for modifications)
- Real-time session state management
- Theme integration with VSCode

## How Commands Work

Every command generates a prompt that the user copies to the Agent window. Commands do NOT make file changes directly - they create prompts that instruct the agent to make changes.

The prompts are artfully constructed to:
- Call relevant MCP tools (get_Foundry_about, get_Foundry_schema, get_Foundry_context)
- Include all necessary file contents
- Follow context linkages
- Provide clear, specific instructions
- Emphasize minimal story size for distillation

## MCP Server Tools

The @forge/mcp-server provides:

### get_forge_about
Returns comprehensive overview of Forge workflow including:
- Session-driven approach
- When to create Stories vs Tasks
- Minimal story size guidance
- File structure and linkages

### get_forge_schema
Returns schema for: session, feature, spec, actor, story, task, context
Each schema includes:
- File format and naming
- Frontmatter fields
- Content structure
- Linkage rules

### get_forge_context
Takes spec_object parameter
Returns guidance for technical objects or research prompt if not found

### get_forge_objects
Lists supported spec objects from guidance library

## Current Development Approach

We are actively using Forge to build Forge itself, creating a comprehensive documentation and design system that includes:

- **Studio Features**: Complete user experience features for all Forge Studio interfaces (Dashboard, Sessions, Features, Specs, Actors, Contexts)
- **Session Management**: Features for starting, managing, and distilling design sessions
- **File Management**: Features for creating, editing, and organizing all Forge file types
- **MCP Integration**: Features for MCP server functionality and AI agent integration
- **VSCode Extension**: Features for the extension host integration and command system

## Overall Goal

Forge should help users design good prompts with proper context through a session-driven workflow. The prompts generated are intelligent, follow all necessary linkages, and ensure AI agents have complete, accurate context for implementation.

The magic of Forge is in the construction of these prompts and how document linkages are used to generate them with complete context but no overload. By using Forge to build Forge, we demonstrate the power of this approach and create a comprehensive reference implementation.
