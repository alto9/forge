---
actor_id: ai-agent
name: AI Agent
type: system
description: The AI agent that receives prompts from Forge commands and executes implementation work
---

# AI Agent Actor

## Profile
The AI Agent is an AI-powered assistant (typically Claude or similar) that operates within Cursor IDE. It receives structured prompts generated by Forge commands and executes implementation work, including creating documentation, writing code, and managing file changes.

## Capabilities
- Execute structured prompts with MCP tool calls
- Read and analyze codebases
- Create and modify files (code and documentation)
- Follow Gherkin scenarios and technical specifications
- Generate implementation code from stories
- Create features, diagrams, specs, and models
- Maintain file linkages and frontmatter
- Track session changes

## Responsibilities
- **Design Sessions**: Create/modify features, diagrams, specs, models based on design prompts
- **Distillation**: Convert design sessions into minimal, actionable stories and tasks
- **Implementation**: Execute stories by writing code based on linked documentation
- **Context Awareness**: Use MCP tools to understand Forge workflow and schemas
- **Quality**: Ensure proper formatting (Gherkin, Nomnoml, frontmatter)

## Workflow Integration

### With Developer (Human Actor)
- Receives prompts copied from Forge output panel
- Executes prompts to create/modify files
- Provides implementation feedback and results

### With VSCode/Forge (System Actor)
- Receives structured prompts from Forge commands
- Calls MCP tools as instructed in prompts
- Accesses file system through Cursor IDE

### With MCP Server (System Actor)
- Calls `get_forge_about` to understand workflow
- Calls `get_forge_schema` to get file format schemas
- Calls `get_forge_context` to get technical guidance
- Calls `get_forge_objects` to discover available guidance

## Constraints
- Must follow session requirements (active session for features/diagrams/specs)
- Must maintain proper file formats (Gherkin in code blocks, YAML frontmatter)
- Must keep stories minimal (< 30 minutes implementation)
- Must preserve linkages (feature_id, spec_id, diagram_id, etc.)
- Must use kebab-case for IDs and filenames

## Key Behaviors

### During Design Sessions
1. Call `get_forge_about` to understand workflow
2. Call `get_forge_schema` for relevant file types
3. Read existing documentation for context
4. Create or modify features, diagrams, specs, models
5. Ensure proper frontmatter and linkages
6. Track all changes

### During Distillation
1. Call `get_forge_about` for distillation principles
2. Read session file and all changed files
3. Analyze features/diagrams/specs/models modified
4. Break down changes into minimal stories (< 30 min each)
5. Create stories and tasks in session ticket folder
6. Link stories to relevant features, specs, diagrams
7. Include clear acceptance criteria

### During Implementation
1. Call `get_forge_about` for build guidance
2. Read story file and linked documentation
3. Analyze existing codebase patterns
4. Implement changes as specified in story
5. Write tests as specified
6. Match existing code conventions

## Success Criteria
- Prompts executed correctly without errors
- Files created with proper format and frontmatter
- Sessions tracked accurately with changed files
- Stories are minimal and focused
- Implementation matches specifications
- Complete context without overload

